# [μµλ‹¨ κ²½λ΅] λ‹¤μµμ¤νΈλΌ(Dijkstra) π—
### λ¬Έμ 
- λ‹¤μ–‘ν• λ¬Έμ  μƒν™©
    - ν• μ§€μ μ—μ„ λ‹¤λ¥Έ ν• μ§€μ κΉμ§€μ μµλ‹¨ κ²½λ΅
    - ν• μ§€μ μ—μ„ λ‹¤λ¥Έ λ¨λ“  μ§€μ κΉμ§€μ μµλ‹¨ κ²½λ΅
    - λ¨λ“  μ§€μ μ—μ„ λ‹¤λ¥Έ λ¨λ“  μ§€μ κΉμ§€μ μµλ‹¨ κ²½λ΅
- κ° μ§€μ μ€ κ·Έλν”„μ—μ„ λ…Έλ“λ΅ ν‘ν„
- μ§€μ  κ°„ μ—°κ²°λ λ„λ΅λ” κ·Έλν”„μ—μ„ κ°„μ„ μΌλ΅ ν‘ν„


### λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦
- νΉμ •ν• λ…Έλ“μ—μ„ μ¶λ°ν•μ—¬ λ‹¤λ¥Έ λ¨λ“  λ…Έλ“λ΅ κ°€λ” μµλ‹¨ κ²½λ΅λ¥Ό κ³„μ‚°
- λ‹¤μµμ¤νΈλΌ μµλ‹¨ κ²½λ΅ μ•κ³ λ¦¬μ¦μ€ **μμ κ°„μ„ μ΄ μ—†μ„ λ•** μ •μƒμ μΌλ΅ λ™μ‘
- λ§¤ μƒν™©μ—μ„ κ°€μ¥ λΉ„μ©μ΄ μ μ€ λ…Έλ“λ¥Ό μ„ νƒν•΄ μ„μμ κ³Όμ •μ„ λ°λ³µ


### λ™μ‘ κ³Όμ •
1. μ¶λ° λ…Έλ“ μ„¤μ •
2. μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ” μ΄κΈ°ν™”
3. λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘μ—μ„ μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“ μ„ νƒ
4. ν•΄λ‹Ή λ…Έλ“λ¥Ό κ±°μ³ λ‹¤λ¥Έ λ…Έλ“λ΅ κ°€λ” λΉ„μ©μ„ κ³„μ‚°ν•μ—¬ μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ” κ°±μ‹ 
5. μ„ κ³Όμ •μ—μ„ 3λ²κ³Ό 4λ²μ„ λ°λ³µ


### λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦ νΉμ§•
- κ·Έλ¦¬λ”” μ•κ³ λ¦¬μ¦: λ§¤ μƒν™©μ—μ„ λ°©λ¬Έν•μ§€ μ•μ€ κ°€μ¥ λΉ„μ©μ΄ μ μ€ λ…Έλ“λ¥Ό μ„ νƒν•΄ μ„μμ κ³Όμ •μ„ λ°λ³µ
- λ‹¨κ³„λ¥Ό κ±°μΉλ©° ν• λ² μ²λ¦¬λ λ…Έλ“μ μµλ‹¨ κ±°λ¦¬λ” κ³ μ •λμ–΄ λ” μ΄μƒ λ°”λ€μ§€ μ•μ
    - ν• λ‹¨κ³„ λ‹Ή ν•λ‚μ λ…Έλ“μ— λ€ν• μµλ‹¨ κ±°λ¦¬λ¥Ό ν™•μ‹¤ν μ°Ύλ” κ²ƒμΌλ΅ μ΄ν•΄ν•  μ μμ
- λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ„ μν–‰ν• ν›„μ—λ” ν…μ΄λΈ”μ— κ° λ…Έλ“κΉμ§€μ μµλ‹¨ κ±°λ¦¬ μ •λ³΄κ°€ μ €μ¥


### μ½”λ“
```java
import java.util.*;
import java.io.*;

class Solution {
	static int n;
	static ArrayList<Node>[] graph;
    
    public static void Dijkstra(int start) {
    	boolean[] visited = new boolean[n+1];
        int[] dist = new int[n+1];
        int INF = Integer.MAX_VALUE;
        
        Array.fill(dist, INF);
        dist[start] = 0;
        
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));
        
        while(!pq.isEmpty()) {
        	int nowVertex = pq.poll().idx;
            
            if(visited[nowVertex]) continue;
            visited[nowVertex] = true;
            
            for(Node nxt: graph[nowVertex]) {
            	if(dist[nxt.idx] > dist[nowVertex]+nxt.cost) {
                	dist[nxt.idx] = dist[nowVertex]+nxt.cost;
                    
                    pq.offer(new Node(nxt.idx, dist[nxt.idx]));
                }
            }
        }
    
    	for(int d: dist) {
        	if(d == INF) System.out.println("INF");
            else System.out.println(d);
        }
    }
    
    public static void main(String[] args) throws IOException {
    	BufferedReader br = new BufferedReader();
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        
        graph = new ArrayList[n+1];
        
        for(int i=0; i<n; i++) {
        	graph[i] = new ArrayList<>();
        }
        
        for(int i=0; i<m; i++) {
        	st = new StringTokenizer(br.readLine());
            int from = Integer.parseInt(st.nextToken());
        	int to = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            graph[from].add[new Node(to, cost)];
        }
        
        int start = Integer.parseInt(br.readLine());
        
        Dijkstra(start);
    }
}


class Node implements Comparable<Node> {
	int idx, cost;
    
    public Node(int idx, int cost) {
    	this.idx = idx;
        this.cost = cost;
    }
    
    @Override
    public int compareTo(Node o) {
    	return Integer.compare(this.cost, o.cost);
    }
}
```

### μ„±λ¥ λ¶„μ„
- ν™ μλ£κµ¬μ΅°λ¥Ό μ΄μ©ν•λ” λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ μ‹κ°„ λ³µμ΅λ„λ” $O(ElogV)$
- λ…Έλ“λ¥Ό ν•λ‚μ”© κΊΌλ‚΄ κ²€μ‚¬ν•λ” λ°λ³µλ¬Έ(whileλ¬Έ)μ€ λ…Έλ“μ κ°μ V μ΄μƒμ νμλ΅λ” μ²λ¦¬λμ§€ μ•μ
    - κ²°κ³Όμ μΌλ΅ ν„μ¬ μ°μ„ μμ„ νμ—μ„ κΊΌλ‚Έ λ…Έλ“μ™€ μ—°κ²°λ λ‹¤λ¥Έ λ…Έλ“λ“¤μ„ ν™•μΈν•λ” μ΄ νμλ” μµλ€ κ°„μ„ μ κ°μ(E)λ§νΌ μ—°μ‚°μ΄ μν–‰λ  μ μμ
- μ§κ΄€μ μΌλ΅ μ „μ²΄ κ³Όμ •μ€ Eκ°μ μ›μ†λ¥Ό μ°μ„ μμ„ νμ— λ„£μ—λ‹¤κ°€ λ¨λ‘ λΉΌλ‚΄λ” μ—°μ‚°κ³Ό λ§¤μ° μ μ‚¬
    - μ‹κ°„ λ³µμ΅λ„λ¥Ό $O(ElogE)$λ΅ νλ‹¨
    - μ¤‘λ³µ κ°„μ„ μ„ ν¬ν•¨ν•μ§€ μ•λ” κ²½μ°μ— μ΄λ¥Ό $O (ElogV)$λ΅ μ •λ¦¬
    $O(ElogE)$ β†’ $O(EloqV2)$ β†’ $O(2ElogV)$ β†’ $O(ElogV)$